# refcat-implementation.conv - Multi-phase implementation workflow for REFCAT
# Created: 2026-01-23
# Context: Identified during Nightscout ecosystem evaluation
# Run: sdqctl iterate proposals/REFCAT-DIRECTIVE.conv --adapter copilot --max-cycles 4
#
# Design Principle: This workflow references proposals/REFCAT-DESIGN.md for specs.
# The .conv file orchestrates work phases; the .md file holds the details.
# See docs/WORKFLOW-DESIGN.md for rationale.

MODEL gpt-4o
ADAPTER copilot
MODE implementation
MAX-CYCLES 4
VALIDATION-MODE lenient
CWD {{CWD}}

# Design spec - the source of truth for REFCAT requirements
CONTEXT @proposals/REFCAT-DESIGN.md

# Phase 1 context: Existing code to understand
CONTEXT-OPTIONAL @sdqctl/core/context.py
CONTEXT-OPTIONAL @sdqctl/core/renderer.py
CONTEXT-OPTIONAL @sdqctl/verifiers/refs.py

PROLOGUE |
  Session: {{DATE}} | REFCAT Implementation
  Branch: {{GIT_BRANCH}}
  Phase: Multi-phase implementation (research → design → implement → test)
  
  Reference: proposals/REFCAT-DESIGN.md contains the full specification.

# ============================================================================
# PHASE 1: Research existing design space
# ============================================================================

PROMPT |
  ## Phase 1: Research Design Space
  
  Review the REFCAT design in proposals/REFCAT-DESIGN.md.
  
  Analyze the existing context injection pattern in `context.py` and `renderer.py`.
  
  Key questions:
  1. How are files currently labeled when injected?
  2. How are @paths resolved relative to CWD vs workflow dir?
  3. Where should REFCAT hook into the existing context system?
  
  Propose integration points for REFCAT.

ELIDE

RUN grep -n "rel_path\|get_context_content" sdqctl/core/context.py 2>/dev/null || echo "Pattern not found"

ELIDE

PROMPT |
  Based on the grep output and your analysis, summarize:
  1. The current context injection format
  2. What's missing for REFCAT use case
  3. Proposed changes to `get_context_content()` method

# ============================================================================
# PHASE 2: Design specification
# ============================================================================

COMPACT
COMPACT-SUMMARY Phase 1 complete. Researched context injection patterns.

PROMPT |
  ## Phase 2: Review and Refine Design
  
  The REFCAT design specification is in proposals/REFCAT-DESIGN.md.
  
  Review the existing design and:
  1. Verify the ref syntax specification covers all use cases
  2. Confirm error handling semantics are correct
  3. Propose any refinements based on your Phase 1 analysis
  
  If refinements are needed, update proposals/REFCAT-DESIGN.md.

RUN-ON-ERROR continue
RUN mkdir -p proposals 2>/dev/null || true

OUTPUT-FORMAT markdown
OUTPUT-FILE proposals/REFCAT-DESIGN.md

# Git checkpoint: save design before implementation
ELIDE

RUN git --no-pager diff --stat proposals/

PROMPT |
  If REFCAT-DESIGN.md was updated, commit it now:
  ```bash
  git add proposals/REFCAT-DESIGN.md
  git commit -m "docs: REFCAT design specification - <brief summary of key decisions>"
  ```

# ============================================================================
# PHASE 3: Implementation
# ============================================================================

COMPACT
COMPACT-SUMMARY Phase 2 complete. Design reviewed and committed.

PROMPT |
  ## Phase 3: Implementation
  
  Implement REFCAT following the architecture in Section 4 of proposals/REFCAT-DESIGN.md.
  
  Create these components:
  1. Core module: `sdqctl/core/refcat.py`
  2. CLI command: `sdqctl/commands/refcat.py`
  3. Update `conversation.py` with REFCAT directive type
  
  Start with the core module. Follow the dataclass and function signatures in the design doc.

RUN-ON-ERROR continue

ELIDE

PROMPT After implementing, show the key functions and their signatures.

# Git checkpoint: save implementation before tests
ELIDE

RUN git --no-pager diff --stat sdqctl/

ELIDE

RUN git --no-pager status --short

PROMPT |
  Review the changes above. If core implementation files exist:
  1. Stage the new/modified files
  2. Commit as work-in-progress with a descriptive message
  
  Example:
  ```bash
  git add sdqctl/core/refcat.py sdqctl/commands/refcat.py
  git commit -m "feat(wip): REFCAT core - <what you implemented>"
  ```

# ============================================================================
# PHASE 4: Testing and Documentation
# ============================================================================

COMPACT
COMPACT-SUMMARY Phase 3 complete. Core implementation committed as WIP.

PROMPT |
  ## Phase 4: Testing and Documentation
  
  Following Section 5 of proposals/REFCAT-DESIGN.md:
  
  1. Create `tests/test_refcat.py` with tests for parsing, extraction, and errors
  2. Run tests and fix any failures
  3. Update docs (README.md, DIRECTIVES.md if it exists) with REFCAT usage

RUN python -m pytest tests/test_refcat.py -v 2>&1 | head -50

RUN-RETRY 3 "Fix any failing tests based on the error output"

PROMPT |
  Final steps:
  1. Stage all relevant files
  2. Write a descriptive commit message
  3. Verify no regressions with full test suite

ELIDE

RUN git --no-pager diff --stat

ELIDE

RUN git --no-pager status --short

PROMPT |
  Review the changes above. If tests pass and docs are updated:
  
  1. Stage all relevant files
  2. Write a descriptive commit message summarizing:
     - What REFCAT does
     - Key features implemented
     - Files created/modified
  3. Commit and show the result
  
  Then verify no regressions:
  ```bash
  python -m pytest tests/ -v --tb=short 2>&1 | tail -20
  ```
  
  Then verify no regressions:
  ```bash
  python -m pytest tests/ -v --tb=short 2>&1 | tail -20
  ```

EPILOGUE |
  ## Session Complete
  
  Artifacts created:
  - proposals/REFCAT-DESIGN.md - Design specification
  - sdqctl/core/refcat.py - Core implementation
  - sdqctl/commands/refcat.py - CLI command
  - tests/test_refcat.py - Test suite
  
  Verify with:
  ```bash
  sdqctl refcat @sdqctl/core/context.py#L182-L194
  sdqctl verify refs .  # Ensure no regressions
  ```
