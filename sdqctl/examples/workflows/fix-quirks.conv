# fix-quirks.conv - Iterate through quirks with research/implement phases
#
# An optimized workflow for addressing known quirks one at a time.
# Designed to minimize context usage while maintaining focus.
#
# Usage:
#   sdqctl cycle examples/workflows/fix-quirks.conv --adapter copilot
#   sdqctl cycle examples/workflows/fix-quirks.conv --adapter copilot -n 2  # Fix 2 quirks
#
# Terminology:
#   - CYCLE = one complete pass through all 4 phases (fixes ONE quirk)
#   - PHASE = each prompt within a cycle (select → execute → verify → triage)
#
# Design principles (following QUIRKS.md guidance):
# 1. Implementation-oriented filename (fix-, not track-)
# 2. Minimal context injection - agent reads files on demand
# 3. Explicit role clarification in PROLOGUE
# 4. Single quirk focus per CYCLE
# 5. Research blockers handled before implementation

MODEL claude-opus-4.5
ADAPTER copilot
MODE implement
MAX-CYCLES 1

# === Context Management ===
# Compact after phase 2 (implementation) to free context for verification
CONTEXT-LIMIT 70%
ON-CONTEXT-LIMIT compact
COMPACT-PRESERVE prompts,errors,tool-results

# === Role Clarification ===
# Explicit implementation intent to override any filename inference
PROLOGUE You are an implementation assistant. Your job is to EDIT FILES directly.
PROLOGUE Do not describe changes - make them using edit tools.
PROLOGUE When blocked by missing information, document the blocker and stop.

# === Minimal Session Context ===
PROLOGUE ---
PROLOGUE Session: {{DATETIME}} | Branch: {{GIT_BRANCH}}
PROLOGUE ---

# === Implementation Reminders ===
EPILOGUE ---
EPILOGUE Remember:
EPILOGUE - ONE quirk per cycle (do not batch)
EPILOGUE - Research blockers → document and stop
EPILOGUE - Implementation ready → edit files directly
EPILOGUE - Test changes before marking complete

# === Phase 1: Select and Assess ===
PROMPT ## Phase 1: Quirk Selection

Review the quirks backlog at `docs/QUIRKS.md`.

**Task:** Select ONE quirk to work on this cycle.

Selection criteria:
1. P0 quirks before P1/P2
2. Quirks with clear "Future Fix Options" 
3. Quirks where implementation is unblocked

**Output format:**
```
### Selected: Q-XXX
**Title:** [from QUIRKS.md]
**Priority:** P0/P1/P2
**Status:** Research needed | Ready to implement
**Blocker (if any):** [what's missing]
**Approach:** [which fix option, or research needed]
```

If the quirk needs research first, state what information is missing.
If ready to implement, state which fix option you'll use.

# === Phase 2: Research or Implement ===
PROMPT ## Phase 2: Execute

Based on your Phase 1 assessment:

**If research needed:**
1. Investigate the codebase to gather missing information
2. Document findings in a new section of `docs/QUIRKS.md` under the quirk
3. Update the quirk's status with research results
4. If now unblocked, proceed to implementation

**If ready to implement:**
1. Implement the fix using the approach you identified
2. Make minimal, surgical changes
3. Add or update tests if the fix is testable

**Do NOT just describe changes. Edit files directly.**

# Run tests after implementation phase to verify changes
RUN-ON-ERROR continue
RUN-OUTPUT on-error
RUN-TIMEOUT 2m
RUN python -m pytest tests/ -v --tb=short -x

# Compact after implementation to free context for verification
COMPACT

# === Phase 3: Verify and Document ===
PROMPT ## Phase 3: Completion

The test results from Phase 2 are shown above (if any failures occurred).

Summarize the work and update tracking.

**If tests passed and implementation completed:**
1. Update `docs/QUIRKS.md`:
   - Change quirk status to "Fixed" or "Mitigated"
   - Add implementation notes
2. List files modified

**If tests failed:**
1. Analyze the failure output above
2. Fix the issue if straightforward
3. If complex, document the failure and stop

**If blocked (no implementation attempted):**
1. Update `docs/QUIRKS.md` with:
   - What was learned
   - What's still missing
   - Suggested next steps
2. Do NOT attempt workarounds - document and stop

**Output:**
```
### Phase 3 Result: Q-XXX
**Outcome:** Completed | Blocked | Partial | Tests Failed
**Files changed:** [list]
**Tests:** Pass | Fail | N/A
**Next action:** [if blocked or failed, what's needed]
```
COMPACT

# === Phase 4: Research and Triage ===
PROMPT ## Phase 4: Triage

Review the current state of `docs/QUIRKS.md`.

**Check for:**
1. Are there additional quirks that should be documented based on today's work?
2. Does any quirk need further human review before implementation?
3. Are there blockers that require upstream changes (SDK, Copilot, etc.)?

**If additional quirks found:**
- Add them to QUIRKS.md with appropriate priority
- Mark as "Needs Research" or "Blocked" if not immediately actionable

**If human review required:**
- Document specific questions that need human input
- Do NOT attempt implementation without answers

**Output:**
```
### Cycle Complete: Q-XXX
**Outcome:** Fixed | Mitigated | Blocked | Partial
**New quirks added:** N (list IDs if any)
**Ready for next cycle:** [list of actionable quirk IDs]
**Human review needed:** Yes/No
**Questions for human:** [if any]
```

# Final test run to confirm everything passes
RUN-ON-ERROR continue
RUN-OUTPUT always
RUN-TIMEOUT 2m
RUN python -m pytest tests/ -v --tb=short --co -q | head -20

COMPACT
PROMPT If the tests passed, let's ensure docs are up to date and then check our relevant work into git.
COMPACT

# === Output Configuration ===
OUTPUT-FORMAT markdown

# === Notes ===
# This workflow intentionally:
# - Uses 4 PHASES per cycle: select → execute → verify → triage
# - MAX-CYCLES 1 = fix ONE quirk (use -n 2 for two quirks, etc.)
# - Does NOT inject docs/QUIRKS.md as CONTEXT (agent reads on demand)
# - Does NOT use {{WORKFLOW_NAME}} in prompts (avoids Q-001)
# - Uses explicit implementation language in PROLOGUE
# - Stops on blockers rather than working around them
# - Final phase checks for new quirks and human review needs
